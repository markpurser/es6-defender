/**
 * @license
 * es6-defender.min.js - v0.0.1
 *
 * Licensed under the MIT License.
 * http://github.com/markpurser/es6-defender/LICENSE
*/

'use strict';

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PlayerState = Object.freeze({ faceLeft: 1, faceRight: 2, exploding: 3 });

var InvaderState = Object.freeze({ seeking: 1, locked: 2, abducting: 3, mutant: 4, exploding: 5 });

var Event = Object.freeze({ locked: 1, abducted: 2, mutated: 3, dead: 4, remove: 5 });

var easing = 0.3;
var modulus = 512;

var StateVector = function StateVector(id, x, y, xdot, ydot) {
  _classCallCheck(this, StateVector);

  this.id = id;
  this.x = x;
  this.y = y;
  this.xdot = xdot;
  this.ydot = ydot;
};

var Player = function (_StateVector) {
  _inherits(Player, _StateVector);

  function Player(id, x, y, state, t_startState) {
    _classCallCheck(this, Player);

    var _this = _possibleConstructorReturn(this, (Player.__proto__ || Object.getPrototypeOf(Player)).call(this, id, x, y, 0, 0));

    _this.state = state;
    _this.t_startState = t_startState;
    return _this;
  }

  return Player;
}(StateVector);

Player.sideLen = 3;
Player.graphic = ['  /\n<--', '\\  \n-->'];

var Invader = function (_StateVector2) {
  _inherits(Invader, _StateVector2);

  function Invader(id, x, y, state, t_startState) {
    _classCallCheck(this, Invader);

    var _this2 = _possibleConstructorReturn(this, (Invader.__proto__ || Object.getPrototypeOf(Invader)).call(this, id, x, y, 0, 0));

    _this2.state = state;
    _this2.t_startState = t_startState;
    return _this2;
  }

  return Invader;
}(StateVector);

Invader.sideLen = 2;
Invader.graphic = '^^\n[]\n';

var Human = function (_StateVector3) {
  _inherits(Human, _StateVector3);

  function Human(id, x, y) {
    _classCallCheck(this, Human);

    return _possibleConstructorReturn(this, (Human.__proto__ || Object.getPrototypeOf(Human)).call(this, id, x, y, 0, 0));
  }

  return Human;
}(StateVector);

var Projectile = function (_StateVector4) {
  _inherits(Projectile, _StateVector4);

  function Projectile() {
    _classCallCheck(this, Projectile);

    return _possibleConstructorReturn(this, (Projectile.__proto__ || Object.getPrototypeOf(Projectile)).apply(this, arguments));
  }

  return Projectile;
}(StateVector);

Projectile.sideLen = 1;
Projectile.graphic = ['*'];

var updatePlayerPosition = function updatePlayerPosition(sv, input) {
  sv.x += input.leftright;
  sv.y += input.updown;

  sv.x %= modulus;

  return sv;
};

var updateInvaderPosition = function updateInvaderPosition(sv, state, targetx, targety) {
  switch (state) {
    case InvaderState.seeking:
      sv.x++;
      break;
  }

  sv.x %= modulus;

  return sv;
};

var cartesianProduct2 = function cartesianProduct2(arr1, arr2) {
  return arr1.map(function (e1) {
    return arr2.map(function (e2) {
      return { fst: e1, snd: e2 };
    });
  }).reduce(function (arr, e) {
    return arr.concat(e);
  }, []);
};

var haveCollided = function haveCollided(_ref, size1, _ref2, size2) {
  var x1 = _ref.x,
      y1 = _ref.y;
  var x2 = _ref2.x,
      y2 = _ref2.y;
  return x2 < x1 + size1 && x1 < x2 + size2 && y2 < y1 + size1 && y1 < y2 + size2;
};

var detectCollisions = function detectCollisions(svArr1, size1, svArr2, size2) {
  return cartesianProduct2(svArr1, svArr2).filter(function (svPair) {
    return haveCollided(svPair.fst, size1, svPair.snd, size2);
  });
};

var checkSeekingInvaders = function checkSeekingInvaders(invaders, humans) {};

var checkHitInvaders = function checkHitInvaders(invaders, projectiles) {
  return detectCollisions(invaders, Invader.sideLen, projectiles, Projectile.sideLen).map(function (collidedPair) {
    Event.dead, collidedPair.fst.id, collidedPair.snd.id;
  });
};

var initArray = function initArray(n, f) {
  return Array(n).fill().map(f);
};

var offsetx = 0;
var playerId = 1;
var invaderId = 100;
var player = new Player(playerId, 0, 64 / 2, PlayerState.faceRight, 0);
var invaders = initArray(2, function (_) {
  return new Invader(invaderId++, Math.floor(Math.random() * modulus), 64 / 2, InvaderState.seeking, 0);
});
// humanId = 200;
// let humans = initArray(10, _ => new Human(id++, 4, 1));
var displayStrings = new Map();

var doGame = function doGame(fastTextMode, viewWidth, viewHeight, input) {

  var toLocal = function toLocal(sv) {
    var lx = sv.x - offsetx;
    lx += viewWidth / 2;

    if (lx < 0 || lx >= viewWidth) {
      lx -= modulus;
    }

    var ly = sv.y;

    return { id: sv.id, lx: lx, ly: ly };
  };

  var clip = function clip(lcoords) {
    return lcoords.lx >= 0 && lcoords.ly < viewWidth;
  };

  if (input.leftright != 0) {
    var index = 1;
    if (input.leftright == -1) index = 0;
    displayStrings.set(player.id, Player.graphic[index]);
  }

  invaders.map(function (i) {
    return displayStrings.set(i.id, Invader.graphic);
  });

  var displayArray = [].concat(updatePlayerPosition(player, input), invaders.map(function (i) {
    return updateInvaderPosition(i, i.state, 0, 0);
  }));

  displayArray.map(toLocal).filter(clip).map(function (i) {
    return fastTextMode.setString(Math.floor(i.lx), Math.floor(i.ly), displayStrings.has(i.id) ? displayStrings.get(i.id) : '!');
  });

  var lpx = player.x - offsetx;
  lpx += viewWidth / 2;
  offsetx += easing * (lpx - viewWidth / 2);

  offsetx %= modulus;

  // let e = checkSeekingInvaders(invaders.filter(i => i.state == InvaderState.seeking), humans);

};
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
* FastTextMode
*
* Copyright (C) 2016  Mark Purser
* Released under the MIT license
* http://github.com/markpurser/fast-text-mode/LICENSE
*
* Tile rendering based on
* https://github.com/jice-nospam/yendor.ts
* Copyright (c) 2014 Jice
*/

/**
* @module FastTextMode
*/

var FastTextMode = function () {
    function FastTextMode() {
        _classCallCheck(this, FastTextMode);
    }

    _createClass(FastTextMode, [{
        key: 'init',
        value: function init(options) {
            var _this = this;

            options = options || {};
            Object.keys(FastTextMode.defaults).forEach(function (key) {
                if (!(key in options)) options[key] = FastTextMode.defaults[key];
            });

            _this._options = options;

            return new Promise(function (resolve, reject) {
                // create a new instance of a pixi container
                _this._parentContainer = new PIXI.Container();

                _this._tileTextures = [];

                // create a renderer instance
                var pixiOptions = {
                    clearBeforeRender: true,
                    preserveDrawingBuffer: false,
                    resolution: 1,
                    view: options.renderCanvas
                };

                _this._renderer = PIXI.autoDetectRenderer(options.renderCanvasSize.width, options.renderCanvasSize.height, pixiOptions);
                _this._renderer.backgroundColor = 0x66ff99;

                _this._stats = {
                    fpsText: new PIXI.Text('', { font: '24px Arial', fill: 0xff1010 }),
                    fpsTimer: 0,
                    currentFrameCount: 0
                };

                var loader = PIXI.loader;
                loader.add('tilesheet', options.tilesheetImage);

                loader.load(function (loader, resources) {
                    var numTilesX = resources.tilesheet.texture.width / options.tileWidthPx;
                    var numTilesY = resources.tilesheet.texture.height / options.tileHeightPx;

                    // init tile textures
                    for (var x = 0; x < numTilesX; x++) {
                        for (var y = 0; y < numTilesY; y++) {
                            var rect = new PIXI.Rectangle(x * options.tileWidthPx, y * options.tileHeightPx, options.tileWidthPx, options.tileHeightPx);
                            _this._tileTextures[x + y * numTilesX] = new PIXI.Texture(resources.tilesheet.texture, rect);
                        }
                    }

                    _this._worldSpriteContainer = new SpriteGrid(options.viewWidth, options.viewHeight, options.tileWidthPx, options.tileHeightPx, _this._tileTextures['.'.codePointAt(0)]);

                    _this._parentContainer.addChild(_this._worldSpriteContainer.getSpriteContainer());
                    _this._parentContainer.addChild(_this._stats.fpsText);

                    resolve();
                });
            });
        }
    }, {
        key: 'render',
        value: function render() {
            if (this._options.displayStats) {
                this.updateStats(this._stats);
            }

            // render
            this._renderer.render(this._parentContainer);

            // clear screen
            for (var x = 0; x < this._options.viewWidth; x++) {
                for (var y = 0; y < this._options.viewHeight; y++) {
                    this.set(x, y, '.');
                }
            }
        }
    }, {
        key: 'set',
        value: function set(x, y, tileCode) {
            if (typeof tileCode === 'string') {
                tileCode = tileCode.codePointAt(0);
            }
            this._worldSpriteContainer.getSprites()[x + y * this._options.viewWidth].texture = this._tileTextures[tileCode];
        }
    }, {
        key: 'setString',
        value: function setString(x, y, tileString) {
            var X = x;
            for (var c = 0; c < tileString.length; c++) {
                var tileCode = tileString.codePointAt(c);
                if (tileCode == 10) {
                    y++;
                    x = X;
                } else {
                    this._worldSpriteContainer.getSprites()[x + y * this._options.viewWidth].texture = this._tileTextures[tileCode];
                    x++;
                }
            }
        }
    }, {
        key: 'updateStats',
        value: function updateStats(stats) {
            stats.currentFrameCount++;
            if (stats.fpsTimer === 0) {
                stats.fpsTimer = new Date().getTime();
            } else if (new Date().getTime() - stats.fpsTimer > 1000) {
                var rendererTypeStr = 'Canvas';
                if (this._renderer instanceof PIXI.WebGLRenderer) {
                    rendererTypeStr = 'WebGL';
                }
                stats.fpsText.text = 'fps: ' + stats.currentFrameCount + '\npixi: ' + PIXI.VERSION + '\nRenderer: ' + rendererTypeStr;
                stats.fpsTimer = new Date().getTime();
                stats.currentFrameCount = 0;
            }
        }
    }]);

    return FastTextMode;
}();

FastTextMode.defaults = {
    renderCanvas: document.getElementById("render-canvas"),
    renderCanvasSize: { width: 1600, height: 900 },
    tilesheetImage: "assets/terminal.png",
    tileWidthPx: 16,
    tileHeightPx: 16,
    viewWidth: 64,
    viewHeight: 64,
    displayStats: true
};

var SpriteGrid = function () {
    function SpriteGrid(gridWidth, gridHeight, tileWidthPx, tileHeightPx, tileTexture) {
        _classCallCheck(this, SpriteGrid);

        this.spriteContainer = new PIXI.Container();
        this.sprites = [];

        // init grid
        for (var x = 0; x < gridWidth; x++) {
            for (var y = 0; y < gridHeight; y++) {
                var sprite = new PIXI.Sprite(tileTexture);
                sprite.position.x = x * tileWidthPx;
                sprite.position.y = y * tileHeightPx;
                sprite.width = tileWidthPx;
                sprite.height = tileHeightPx;
                this.sprites[x + y * gridWidth] = sprite;
                this.spriteContainer.addChild(sprite);
            }
        }
    }

    _createClass(SpriteGrid, [{
        key: 'getSpriteContainer',
        value: function getSpriteContainer() {
            return this.spriteContainer;
        }
    }, {
        key: 'getSprites',
        value: function getSprites() {
            return this.sprites;
        }
    }]);

    return SpriteGrid;
}();
//# sourceMappingURL=es6-defender.min.js.map
